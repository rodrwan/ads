// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const AverageCTR = `-- name: AverageCTR :one
SELECT
  ROUND(COUNT(c.id)::decimal / NULLIF(COUNT(i.id), 0), 4) AS ctr
FROM impressions i
LEFT JOIN clicks c ON c.impression_id = i.id
`

func (q *Queries) AverageCTR(ctx context.Context) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, AverageCTR)
	var ctr pgtype.Numeric
	err := row.Scan(&ctr)
	return ctr, err
}

const CheckCampaignBelongsToAdvertiser = `-- name: CheckCampaignBelongsToAdvertiser :one
SELECT EXISTS (SELECT 1 FROM ad_campaigns WHERE id = $1 AND advertiser_id = $2)
`

type CheckCampaignBelongsToAdvertiserParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	AdvertiserID pgtype.UUID `db:"advertiser_id" json:"advertiser_id"`
}

func (q *Queries) CheckCampaignBelongsToAdvertiser(ctx context.Context, arg CheckCampaignBelongsToAdvertiserParams) (bool, error) {
	row := q.db.QueryRow(ctx, CheckCampaignBelongsToAdvertiser, arg.ID, arg.AdvertiserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const CountActiveAds = `-- name: CountActiveAds :one
SELECT COUNT(*) FROM ads WHERE status = 'active'
`

func (q *Queries) CountActiveAds(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountActiveAds)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountClicks = `-- name: CountClicks :one
SELECT COUNT(*) FROM clicks
`

func (q *Queries) CountClicks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountClicks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountImpressions = `-- name: CountImpressions :one
SELECT COUNT(*) FROM impressions
`

func (q *Queries) CountImpressions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountImpressions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateAd = `-- name: CreateAd :one
INSERT INTO ads (id, campaign_id, title, description, image_url, destination_url, cta_label, targeting_json, status)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id, campaign_id, title, description, image_url, destination_url, cta_label, targeting_json, status, created_at
`

type CreateAdParams struct {
	ID             pgtype.UUID `db:"id" json:"id"`
	CampaignID     pgtype.UUID `db:"campaign_id" json:"campaign_id"`
	Title          pgtype.Text `db:"title" json:"title"`
	Description    pgtype.Text `db:"description" json:"description"`
	ImageUrl       pgtype.Text `db:"image_url" json:"image_url"`
	DestinationUrl pgtype.Text `db:"destination_url" json:"destination_url"`
	CtaLabel       pgtype.Text `db:"cta_label" json:"cta_label"`
	TargetingJson  []byte      `db:"targeting_json" json:"targeting_json"`
	Status         pgtype.Text `db:"status" json:"status"`
}

func (q *Queries) CreateAd(ctx context.Context, arg CreateAdParams) (Ad, error) {
	row := q.db.QueryRow(ctx, CreateAd,
		arg.ID,
		arg.CampaignID,
		arg.Title,
		arg.Description,
		arg.ImageUrl,
		arg.DestinationUrl,
		arg.CtaLabel,
		arg.TargetingJson,
		arg.Status,
	)
	var i Ad
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.ImageUrl,
		&i.DestinationUrl,
		&i.CtaLabel,
		&i.TargetingJson,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const CreateCampaign = `-- name: CreateCampaign :one
INSERT INTO ad_campaigns (id, advertiser_id, name, budget) VALUES ($1, $2, $3, $4) RETURNING id, advertiser_id, name, status, budget, daily_budget, start_date, end_date, created_at
`

type CreateCampaignParams struct {
	ID           pgtype.UUID    `db:"id" json:"id"`
	AdvertiserID pgtype.UUID    `db:"advertiser_id" json:"advertiser_id"`
	Name         string         `db:"name" json:"name"`
	Budget       pgtype.Numeric `db:"budget" json:"budget"`
}

func (q *Queries) CreateCampaign(ctx context.Context, arg CreateCampaignParams) (AdCampaign, error) {
	row := q.db.QueryRow(ctx, CreateCampaign,
		arg.ID,
		arg.AdvertiserID,
		arg.Name,
		arg.Budget,
	)
	var i AdCampaign
	err := row.Scan(
		&i.ID,
		&i.AdvertiserID,
		&i.Name,
		&i.Status,
		&i.Budget,
		&i.DailyBudget,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const CreateClick = `-- name: CreateClick :one
INSERT INTO clicks (id, impression_id) VALUES ($1, $2) RETURNING id, impression_id, clicked_at
`

type CreateClickParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	ImpressionID pgtype.UUID `db:"impression_id" json:"impression_id"`
}

func (q *Queries) CreateClick(ctx context.Context, arg CreateClickParams) (Click, error) {
	row := q.db.QueryRow(ctx, CreateClick, arg.ID, arg.ImpressionID)
	var i Click
	err := row.Scan(&i.ID, &i.ImpressionID, &i.ClickedAt)
	return i, err
}

const CreateImpression = `-- name: CreateImpression :one
INSERT INTO impressions (id, ad_id, placement_id, auction_id, user_context)
        VALUES ($1, $2, $3, $4, $5) RETURNING id, ad_id, placement_id, auction_id, user_context, timestamp
`

type CreateImpressionParams struct {
	ID          pgtype.UUID `db:"id" json:"id"`
	AdID        pgtype.UUID `db:"ad_id" json:"ad_id"`
	PlacementID pgtype.UUID `db:"placement_id" json:"placement_id"`
	AuctionID   pgtype.UUID `db:"auction_id" json:"auction_id"`
	UserContext []byte      `db:"user_context" json:"user_context"`
}

func (q *Queries) CreateImpression(ctx context.Context, arg CreateImpressionParams) (Impression, error) {
	row := q.db.QueryRow(ctx, CreateImpression,
		arg.ID,
		arg.AdID,
		arg.PlacementID,
		arg.AuctionID,
		arg.UserContext,
	)
	var i Impression
	err := row.Scan(
		&i.ID,
		&i.AdID,
		&i.PlacementID,
		&i.AuctionID,
		&i.UserContext,
		&i.Timestamp,
	)
	return i, err
}

const CreateSession = `-- name: CreateSession :one
INSERT INTO sessions (token, advertiser_id, expires_at) VALUES ($1, $2, $3) RETURNING token, advertiser_id, expires_at, created_at
`

type CreateSessionParams struct {
	Token        pgtype.UUID      `db:"token" json:"token"`
	AdvertiserID pgtype.UUID      `db:"advertiser_id" json:"advertiser_id"`
	ExpiresAt    pgtype.Timestamp `db:"expires_at" json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, CreateSession, arg.Token, arg.AdvertiserID, arg.ExpiresAt)
	var i Session
	err := row.Scan(
		&i.Token,
		&i.AdvertiserID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const DeleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, token pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteSession, token)
	return err
}

const GetActiveBidsForPlacement = `-- name: GetActiveBidsForPlacement :many
SELECT b.id, b.ad_id, b.bid_price, a.title, a.description, a.image_url, a.destination_url, a.cta_label, a.targeting_json
        FROM bids b
        JOIN ads a ON b.ad_id = a.id
        WHERE b.placement_id = $1 AND a.status = 'active'
`

type GetActiveBidsForPlacementRow struct {
	ID             pgtype.UUID    `db:"id" json:"id"`
	AdID           pgtype.UUID    `db:"ad_id" json:"ad_id"`
	BidPrice       pgtype.Numeric `db:"bid_price" json:"bid_price"`
	Title          pgtype.Text    `db:"title" json:"title"`
	Description    pgtype.Text    `db:"description" json:"description"`
	ImageUrl       pgtype.Text    `db:"image_url" json:"image_url"`
	DestinationUrl pgtype.Text    `db:"destination_url" json:"destination_url"`
	CtaLabel       pgtype.Text    `db:"cta_label" json:"cta_label"`
	TargetingJson  []byte         `db:"targeting_json" json:"targeting_json"`
}

func (q *Queries) GetActiveBidsForPlacement(ctx context.Context, placementID pgtype.UUID) ([]GetActiveBidsForPlacementRow, error) {
	rows, err := q.db.Query(ctx, GetActiveBidsForPlacement, placementID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveBidsForPlacementRow{}
	for rows.Next() {
		var i GetActiveBidsForPlacementRow
		if err := rows.Scan(
			&i.ID,
			&i.AdID,
			&i.BidPrice,
			&i.Title,
			&i.Description,
			&i.ImageUrl,
			&i.DestinationUrl,
			&i.CtaLabel,
			&i.TargetingJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAdPerformanceAnalysis = `-- name: GetAdPerformanceAnalysis :many
SELECT 
    a.id,
    a.title,
    ac.name as campaign_name,
    COUNT(DISTINCT i.id) as impressions,
    COUNT(DISTINCT c.id) as clicks,
    CASE 
        WHEN COUNT(DISTINCT i.id) > 0 
        THEN ROUND(COUNT(DISTINCT c.id)::decimal / COUNT(DISTINCT i.id) * 100, 2)
        ELSE 0 
    END as ctr,
    COALESCE(SUM(ab.price), 0) as total_spend,
    CASE 
        WHEN COALESCE(SUM(ab.price), 0) > 0 
        THEN ROUND(COUNT(DISTINCT c.id)::decimal / COALESCE(SUM(ab.price), 1), 2)
        ELSE 0 
    END as clicks_per_dollar
FROM ads a
JOIN ad_campaigns ac ON a.campaign_id = ac.id
LEFT JOIN impressions i ON i.ad_id = a.id
LEFT JOIN clicks c ON c.impression_id = i.id
LEFT JOIN bids b ON b.ad_id = a.id
LEFT JOIN auction_bids ab ON ab.bid_id = b.id AND ab.is_winner = true
WHERE ac.advertiser_id = $1
GROUP BY a.id, a.title, ac.name
ORDER BY clicks_per_dollar DESC
`

type GetAdPerformanceAnalysisRow struct {
	ID              pgtype.UUID `db:"id" json:"id"`
	Title           pgtype.Text `db:"title" json:"title"`
	CampaignName    string      `db:"campaign_name" json:"campaign_name"`
	Impressions     int64       `db:"impressions" json:"impressions"`
	Clicks          int64       `db:"clicks" json:"clicks"`
	Ctr             int32       `db:"ctr" json:"ctr"`
	TotalSpend      interface{} `db:"total_spend" json:"total_spend"`
	ClicksPerDollar int32       `db:"clicks_per_dollar" json:"clicks_per_dollar"`
}

func (q *Queries) GetAdPerformanceAnalysis(ctx context.Context, advertiserID pgtype.UUID) ([]GetAdPerformanceAnalysisRow, error) {
	rows, err := q.db.Query(ctx, GetAdPerformanceAnalysis, advertiserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAdPerformanceAnalysisRow{}
	for rows.Next() {
		var i GetAdPerformanceAnalysisRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CampaignName,
			&i.Impressions,
			&i.Clicks,
			&i.Ctr,
			&i.TotalSpend,
			&i.ClicksPerDollar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAds = `-- name: GetAds :many
SELECT id, campaign_id, title, description, image_url, destination_url, cta_label, targeting_json, status, created_at FROM ads
`

func (q *Queries) GetAds(ctx context.Context) ([]Ad, error) {
	rows, err := q.db.Query(ctx, GetAds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ad{}
	for rows.Next() {
		var i Ad
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Title,
			&i.Description,
			&i.ImageUrl,
			&i.DestinationUrl,
			&i.CtaLabel,
			&i.TargetingJson,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAdsByCampaign = `-- name: GetAdsByCampaign :many
SELECT id, title, description, image_url, destination_url, cta_label FROM ads WHERE campaign_id = $1
`

type GetAdsByCampaignRow struct {
	ID             pgtype.UUID `db:"id" json:"id"`
	Title          pgtype.Text `db:"title" json:"title"`
	Description    pgtype.Text `db:"description" json:"description"`
	ImageUrl       pgtype.Text `db:"image_url" json:"image_url"`
	DestinationUrl pgtype.Text `db:"destination_url" json:"destination_url"`
	CtaLabel       pgtype.Text `db:"cta_label" json:"cta_label"`
}

func (q *Queries) GetAdsByCampaign(ctx context.Context, campaignID pgtype.UUID) ([]GetAdsByCampaignRow, error) {
	rows, err := q.db.Query(ctx, GetAdsByCampaign, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAdsByCampaignRow{}
	for rows.Next() {
		var i GetAdsByCampaignRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ImageUrl,
			&i.DestinationUrl,
			&i.CtaLabel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAdvertiserByEmail = `-- name: GetAdvertiserByEmail :one
SELECT id, name, email, balance, created_at FROM advertisers WHERE email = $1
`

func (q *Queries) GetAdvertiserByEmail(ctx context.Context, email string) (Advertiser, error) {
	row := q.db.QueryRow(ctx, GetAdvertiserByEmail, email)
	var i Advertiser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Balance,
		&i.CreatedAt,
	)
	return i, err
}

const GetBudgetAlerts = `-- name: GetBudgetAlerts :many
SELECT 
    ac.id,
    ac.name,
    ac.budget,
    COALESCE(SUM(ab.price), 0) as current_spend,
    CASE 
        WHEN ac.budget > 0 
        THEN ROUND((COALESCE(SUM(ab.price), 0)::decimal / ac.budget) * 100, 2)
        ELSE 0 
    END as budget_utilization,
    CASE 
        WHEN ac.daily_budget IS NOT NULL 
        THEN COALESCE(SUM(ab.price), 0) >= ac.daily_budget
        ELSE false 
    END as daily_budget_exceeded
FROM ad_campaigns ac
LEFT JOIN ads a ON a.campaign_id = ac.id
LEFT JOIN bids b ON b.ad_id = a.id
LEFT JOIN auction_bids ab ON ab.bid_id = b.id AND ab.is_winner = true
WHERE ac.advertiser_id = $1 
    AND ac.status = 'active'
GROUP BY ac.id, ac.name, ac.budget, ac.daily_budget
HAVING 
    (ac.budget > 0 AND COALESCE(SUM(ab.price), 0) >= ac.budget * 0.8) OR
    (ac.daily_budget IS NOT NULL AND COALESCE(SUM(ab.price), 0) >= ac.daily_budget * 0.8)
`

type GetBudgetAlertsRow struct {
	ID                  pgtype.UUID    `db:"id" json:"id"`
	Name                string         `db:"name" json:"name"`
	Budget              pgtype.Numeric `db:"budget" json:"budget"`
	CurrentSpend        interface{}    `db:"current_spend" json:"current_spend"`
	BudgetUtilization   int32          `db:"budget_utilization" json:"budget_utilization"`
	DailyBudgetExceeded bool           `db:"daily_budget_exceeded" json:"daily_budget_exceeded"`
}

func (q *Queries) GetBudgetAlerts(ctx context.Context, advertiserID pgtype.UUID) ([]GetBudgetAlertsRow, error) {
	rows, err := q.db.Query(ctx, GetBudgetAlerts, advertiserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBudgetAlertsRow{}
	for rows.Next() {
		var i GetBudgetAlertsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Budget,
			&i.CurrentSpend,
			&i.BudgetUtilization,
			&i.DailyBudgetExceeded,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCampaignByID = `-- name: GetCampaignByID :one
SELECT id, advertiser_id, name, status, budget, daily_budget, start_date, end_date, created_at FROM ad_campaigns WHERE id = $1
`

func (q *Queries) GetCampaignByID(ctx context.Context, id pgtype.UUID) (AdCampaign, error) {
	row := q.db.QueryRow(ctx, GetCampaignByID, id)
	var i AdCampaign
	err := row.Scan(
		&i.ID,
		&i.AdvertiserID,
		&i.Name,
		&i.Status,
		&i.Budget,
		&i.DailyBudget,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const GetCampaignMetrics = `-- name: GetCampaignMetrics :many
SELECT
    COUNT(DISTINCT i.id) as impressions,
    COUNT(DISTINCT c.id) as clicks,
    CASE
        WHEN COUNT(DISTINCT i.id) > 0
        THEN ROUND(COUNT(DISTINCT c.id)::decimal / COUNT(DISTINCT i.id) * 100, 2)
        ELSE 0
    END as ctr
FROM ad_campaigns ac
LEFT JOIN ads a ON a.campaign_id = ac.id
LEFT JOIN impressions i ON i.ad_id = a.id
LEFT JOIN clicks c ON c.impression_id = i.id
WHERE ac.id = $1
GROUP BY ac.id
`

type GetCampaignMetricsRow struct {
	Impressions int64 `db:"impressions" json:"impressions"`
	Clicks      int64 `db:"clicks" json:"clicks"`
	Ctr         int32 `db:"ctr" json:"ctr"`
}

func (q *Queries) GetCampaignMetrics(ctx context.Context, id pgtype.UUID) ([]GetCampaignMetricsRow, error) {
	rows, err := q.db.Query(ctx, GetCampaignMetrics, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCampaignMetricsRow{}
	for rows.Next() {
		var i GetCampaignMetricsRow
		if err := rows.Scan(&i.Impressions, &i.Clicks, &i.Ctr); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCampaignPerformanceAnalysis = `-- name: GetCampaignPerformanceAnalysis :many
SELECT 
    ac.id,
    ac.name,
    ac.budget,
    COALESCE(SUM(ab.price), 0) as total_spend,
    COUNT(DISTINCT i.id) as impressions,
    COUNT(DISTINCT c.id) as clicks,
    CASE 
        WHEN COUNT(DISTINCT i.id) > 0 
        THEN ROUND(COUNT(DISTINCT c.id)::decimal / COUNT(DISTINCT i.id) * 100, 2)
        ELSE 0 
    END as ctr,
    CASE 
        WHEN COALESCE(SUM(ab.price), 0) > 0 
        THEN ROUND(COUNT(DISTINCT c.id)::decimal / COALESCE(SUM(ab.price), 1), 2)
        ELSE 0 
    END as clicks_per_dollar,
    CASE 
        WHEN ac.budget > 0 
        THEN ROUND((COALESCE(SUM(ab.price), 0)::decimal / ac.budget) * 100, 2)
        ELSE 0 
    END as budget_utilization
FROM ad_campaigns ac
LEFT JOIN ads a ON a.campaign_id = ac.id
LEFT JOIN impressions i ON i.ad_id = a.id
LEFT JOIN clicks c ON c.impression_id = i.id
LEFT JOIN bids b ON b.ad_id = a.id
LEFT JOIN auction_bids ab ON ab.bid_id = b.id AND ab.is_winner = true
WHERE ac.advertiser_id = $1
GROUP BY ac.id, ac.name, ac.budget
ORDER BY clicks_per_dollar DESC
`

type GetCampaignPerformanceAnalysisRow struct {
	ID                pgtype.UUID    `db:"id" json:"id"`
	Name              string         `db:"name" json:"name"`
	Budget            pgtype.Numeric `db:"budget" json:"budget"`
	TotalSpend        interface{}    `db:"total_spend" json:"total_spend"`
	Impressions       int64          `db:"impressions" json:"impressions"`
	Clicks            int64          `db:"clicks" json:"clicks"`
	Ctr               int32          `db:"ctr" json:"ctr"`
	ClicksPerDollar   int32          `db:"clicks_per_dollar" json:"clicks_per_dollar"`
	BudgetUtilization int32          `db:"budget_utilization" json:"budget_utilization"`
}

func (q *Queries) GetCampaignPerformanceAnalysis(ctx context.Context, advertiserID pgtype.UUID) ([]GetCampaignPerformanceAnalysisRow, error) {
	rows, err := q.db.Query(ctx, GetCampaignPerformanceAnalysis, advertiserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCampaignPerformanceAnalysisRow{}
	for rows.Next() {
		var i GetCampaignPerformanceAnalysisRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Budget,
			&i.TotalSpend,
			&i.Impressions,
			&i.Clicks,
			&i.Ctr,
			&i.ClicksPerDollar,
			&i.BudgetUtilization,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCampaignSpend = `-- name: GetCampaignSpend :one
SELECT COALESCE(SUM(ab.price), 0) as total_spend
FROM ad_campaigns ac
LEFT JOIN ads a ON a.campaign_id = ac.id
LEFT JOIN bids b ON b.ad_id = a.id
LEFT JOIN auction_bids ab ON ab.bid_id = b.id AND ab.is_winner = true
WHERE ac.id = $1
`

func (q *Queries) GetCampaignSpend(ctx context.Context, id pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, GetCampaignSpend, id)
	var total_spend interface{}
	err := row.Scan(&total_spend)
	return total_spend, err
}

const GetCampaignsByAdvertiser = `-- name: GetCampaignsByAdvertiser :many
SELECT id, name, budget FROM ad_campaigns WHERE advertiser_id = $1
`

type GetCampaignsByAdvertiserRow struct {
	ID     pgtype.UUID    `db:"id" json:"id"`
	Name   string         `db:"name" json:"name"`
	Budget pgtype.Numeric `db:"budget" json:"budget"`
}

func (q *Queries) GetCampaignsByAdvertiser(ctx context.Context, advertiserID pgtype.UUID) ([]GetCampaignsByAdvertiserRow, error) {
	rows, err := q.db.Query(ctx, GetCampaignsByAdvertiser, advertiserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCampaignsByAdvertiserRow{}
	for rows.Next() {
		var i GetCampaignsByAdvertiserRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Budget); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLastImpressionByAdID = `-- name: GetLastImpressionByAdID :one
SELECT id FROM impressions WHERE ad_id = $1 ORDER BY timestamp DESC LIMIT 1
`

func (q *Queries) GetLastImpressionByAdID(ctx context.Context, adID pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, GetLastImpressionByAdID, adID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const GetOptimizationRecommendations = `-- name: GetOptimizationRecommendations :many
WITH campaign_performance AS (
    SELECT 
        ac.id,
        ac.name,
        ac.budget,
        COALESCE(SUM(ab.price), 0) as total_spend,
        COUNT(DISTINCT i.id) as impressions,
        COUNT(DISTINCT c.id) as clicks,
        CASE 
            WHEN COUNT(DISTINCT i.id) > 0 
            THEN ROUND(COUNT(DISTINCT c.id)::decimal / COUNT(DISTINCT i.id) * 100, 2)
            ELSE 0 
        END as ctr,
        CASE 
            WHEN COALESCE(SUM(ab.price), 0) > 0 
            THEN ROUND(COUNT(DISTINCT c.id)::decimal / COALESCE(SUM(ab.price), 1), 2)
            ELSE 0 
        END as clicks_per_dollar
    FROM ad_campaigns ac
    LEFT JOIN ads a ON a.campaign_id = ac.id
    LEFT JOIN impressions i ON i.ad_id = a.id
    LEFT JOIN clicks c ON c.impression_id = i.id
    LEFT JOIN bids b ON b.ad_id = a.id
    LEFT JOIN auction_bids ab ON ab.bid_id = b.id AND ab.is_winner = true
    WHERE ac.advertiser_id = $1 AND ac.status = 'active'
    GROUP BY ac.id, ac.name, ac.budget
)
SELECT 
    id,
    name,
    budget,
    total_spend,
    impressions,
    clicks,
    ctr,
    clicks_per_dollar,
    CASE 
        WHEN clicks_per_dollar > 10 THEN 'increase_budget'
        WHEN clicks_per_dollar < 2 THEN 'decrease_budget'
        WHEN ctr < 1.0 THEN 'improve_creative'
        WHEN impressions < 100 THEN 'increase_bid'
        ELSE 'maintain'
    END as recommendation,
    CASE 
        WHEN clicks_per_dollar > 10 THEN 'Esta campaña tiene excelente ROI. Considera aumentar el presupuesto.'
        WHEN clicks_per_dollar < 2 THEN 'Esta campaña tiene bajo ROI. Considera reducir el presupuesto o mejorar el targeting.'
        WHEN ctr < 1.0 THEN 'CTR bajo. Considera mejorar el creativo o el targeting.'
        WHEN impressions < 100 THEN 'Pocas impresiones. Considera aumentar el bid o mejorar el targeting.'
        ELSE 'Rendimiento estable. Mantén la configuración actual.'
    END as recommendation_text
FROM campaign_performance
ORDER BY clicks_per_dollar DESC
`

type GetOptimizationRecommendationsRow struct {
	ID                 pgtype.UUID    `db:"id" json:"id"`
	Name               string         `db:"name" json:"name"`
	Budget             pgtype.Numeric `db:"budget" json:"budget"`
	TotalSpend         interface{}    `db:"total_spend" json:"total_spend"`
	Impressions        int64          `db:"impressions" json:"impressions"`
	Clicks             int64          `db:"clicks" json:"clicks"`
	Ctr                int32          `db:"ctr" json:"ctr"`
	ClicksPerDollar    int32          `db:"clicks_per_dollar" json:"clicks_per_dollar"`
	Recommendation     string         `db:"recommendation" json:"recommendation"`
	RecommendationText string         `db:"recommendation_text" json:"recommendation_text"`
}

func (q *Queries) GetOptimizationRecommendations(ctx context.Context, advertiserID pgtype.UUID) ([]GetOptimizationRecommendationsRow, error) {
	rows, err := q.db.Query(ctx, GetOptimizationRecommendations, advertiserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOptimizationRecommendationsRow{}
	for rows.Next() {
		var i GetOptimizationRecommendationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Budget,
			&i.TotalSpend,
			&i.Impressions,
			&i.Clicks,
			&i.Ctr,
			&i.ClicksPerDollar,
			&i.Recommendation,
			&i.RecommendationText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSessionByToken = `-- name: GetSessionByToken :one
SELECT advertiser_id FROM sessions WHERE token = $1 AND expires_at > now()
`

func (q *Queries) GetSessionByToken(ctx context.Context, token pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, GetSessionByToken, token)
	var advertiser_id pgtype.UUID
	err := row.Scan(&advertiser_id)
	return advertiser_id, err
}

const InsertAuction = `-- name: InsertAuction :one
INSERT INTO auctions (id, placement_id, request_context) VALUES ($1, $2, $3) RETURNING id, placement_id, request_context, timestamp
`

type InsertAuctionParams struct {
	ID             pgtype.UUID `db:"id" json:"id"`
	PlacementID    pgtype.UUID `db:"placement_id" json:"placement_id"`
	RequestContext []byte      `db:"request_context" json:"request_context"`
}

func (q *Queries) InsertAuction(ctx context.Context, arg InsertAuctionParams) (Auction, error) {
	row := q.db.QueryRow(ctx, InsertAuction, arg.ID, arg.PlacementID, arg.RequestContext)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.PlacementID,
		&i.RequestContext,
		&i.Timestamp,
	)
	return i, err
}

const InsertAuctionBid = `-- name: InsertAuctionBid :one
INSERT INTO auction_bids (id, auction_id, bid_id, price, is_winner) VALUES ($1, $2, $3, $4, $5) RETURNING id, auction_id, bid_id, price, score, is_winner
`

type InsertAuctionBidParams struct {
	ID        pgtype.UUID    `db:"id" json:"id"`
	AuctionID pgtype.UUID    `db:"auction_id" json:"auction_id"`
	BidID     pgtype.UUID    `db:"bid_id" json:"bid_id"`
	Price     pgtype.Numeric `db:"price" json:"price"`
	IsWinner  pgtype.Bool    `db:"is_winner" json:"is_winner"`
}

func (q *Queries) InsertAuctionBid(ctx context.Context, arg InsertAuctionBidParams) (AuctionBid, error) {
	row := q.db.QueryRow(ctx, InsertAuctionBid,
		arg.ID,
		arg.AuctionID,
		arg.BidID,
		arg.Price,
		arg.IsWinner,
	)
	var i AuctionBid
	err := row.Scan(
		&i.ID,
		&i.AuctionID,
		&i.BidID,
		&i.Price,
		&i.Score,
		&i.IsWinner,
	)
	return i, err
}

const UpdateCampaign = `-- name: UpdateCampaign :one
UPDATE ad_campaigns
SET name = $2, budget = $3, daily_budget = $4, start_date = $5, end_date = $6, status = $7
WHERE id = $1 AND advertiser_id = $8
RETURNING id, advertiser_id, name, status, budget, daily_budget, start_date, end_date, created_at
`

type UpdateCampaignParams struct {
	ID           pgtype.UUID    `db:"id" json:"id"`
	Name         string         `db:"name" json:"name"`
	Budget       pgtype.Numeric `db:"budget" json:"budget"`
	DailyBudget  pgtype.Numeric `db:"daily_budget" json:"daily_budget"`
	StartDate    pgtype.Date    `db:"start_date" json:"start_date"`
	EndDate      pgtype.Date    `db:"end_date" json:"end_date"`
	Status       pgtype.Text    `db:"status" json:"status"`
	AdvertiserID pgtype.UUID    `db:"advertiser_id" json:"advertiser_id"`
}

func (q *Queries) UpdateCampaign(ctx context.Context, arg UpdateCampaignParams) (AdCampaign, error) {
	row := q.db.QueryRow(ctx, UpdateCampaign,
		arg.ID,
		arg.Name,
		arg.Budget,
		arg.DailyBudget,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.AdvertiserID,
	)
	var i AdCampaign
	err := row.Scan(
		&i.ID,
		&i.AdvertiserID,
		&i.Name,
		&i.Status,
		&i.Budget,
		&i.DailyBudget,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const UpdateCampaignStatus = `-- name: UpdateCampaignStatus :one
UPDATE ad_campaigns
SET status = $2
WHERE id = $1 AND advertiser_id = $3
RETURNING id, advertiser_id, name, status, budget, daily_budget, start_date, end_date, created_at
`

type UpdateCampaignStatusParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	Status       pgtype.Text `db:"status" json:"status"`
	AdvertiserID pgtype.UUID `db:"advertiser_id" json:"advertiser_id"`
}

func (q *Queries) UpdateCampaignStatus(ctx context.Context, arg UpdateCampaignStatusParams) (AdCampaign, error) {
	row := q.db.QueryRow(ctx, UpdateCampaignStatus, arg.ID, arg.Status, arg.AdvertiserID)
	var i AdCampaign
	err := row.Scan(
		&i.ID,
		&i.AdvertiserID,
		&i.Name,
		&i.Status,
		&i.Budget,
		&i.DailyBudget,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}
